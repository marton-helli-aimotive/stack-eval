{"questionId":"032f2981d80f4ca7bf068fd024246cd1","question":"How do I print an integer in binary with leading zeros?\nI'm doing some bit twiddling and I'd like to print all the bits in my u16.\n\n\n\n```\nlet flags = 0b0000000000101100u16;\nprintln!(\"flags: {:#b}\", flags);\n\n```\n\nThis prints `flags: 0b101100`.\n\n\nHow do I make it print `flags: 0b0000000000101100`?\n\n\n","questionMetadata":{"type":"implementation","level":"intermediate","tag":"rust"},"answer":"I have come to prefer these patterns:\n\n\n\n```\nprintln!(\"{:08b}\", 1i8);\nprintln!(\"{:016b}\", 12000u16);\nprintln!(\"{:032b}\", 624485u32);\n\n```\n\nit will print:\n\n\n\n```\n00000001\n0010111011100000\n00000000000010011000011101100101\n\n```\n\n"}
{"questionId":"be1dc66d8057452690bf559595b2da0c","question":"Android Studio could not find or load main class of \"Scratch\" file\n**Update**: Below problem is remained until `Android Studio 3.4.2`.\n\n\n\n\n---\n\n\nI use `Android Studio 3.3` and created a `scratch` file (`File > new > Scratch File > Java`). The IDE created `scratch.java` in `~\/.AndroidStudio3.3\/config\/scratches`:\n\n\n\n```\nclass Scratch {\n    public static void main(String[] args) {\n\n    }\n}\n\n```\n\nBut when I run that scratch file ( by pressing green button near to the class name or `main` method), I get this error:\n\n\n\n```\nError: Could not find or load main class Scratch\n\n```\n\nI think that IDE does not make `Scratch.class` and so `Java` cannot find it. Is there a way for solving this problem and running scratch files from IDE (without using `Terminal`)?\n\n\n","questionMetadata":{"type":"debugging","level":"intermediate","tag":"java"},"answer":"**Update**\n\n\nI just noticed that this issue was fixed in Android Studio 3.5!\n\n\n\n\n---\n\n\nThe only way I got this to work (in Android Studio 3.4.1) is this **very dirty** approach:\n\n\n1. Go to `Run` > `Edit Configurations` > `Scratch`\n2. In `Before launch` at the bottom add (+) `Run External tool`\n3. In External Tools popup press `+` and fill in the following `Tool Settings`\n\n\n*Name*: `Compile Scratch`\n\n\n*Program*: `javac`\n\n\n*Arguments*: `$FileName$`\n\n\n*Working Directory*: your scratch file directory\n4. Press OK\n5. Again in External Tools popup press `+` and fill in the following `Tool Settings`\n\n\n*Name*: `Run Scratch`\n\n\n*Program*: `java`\n\n\n*Arguments*: `$FileClass$`\n\n\n*Working Directory*: your scratch file directory\n6. Press OK and Apply in Run\/Debug Configurations\n\n\nWeirdly this works only if you use the green arrows beside the class\/main declaration. If you use the Run button in the menu this also fails. \n\n\nYou will still get the not found error in the `Scratch` tab of the run window. But two additional tabs will pop up (one for each external tool). In the `Run Scratch` tab you will get your output.\n\n\nI personally don't like this, But it's the best workaround I came up with.\n\n\n"}
{"questionId":"de9215f8bab046d3aaa5ab5909cdb491","question":"In Java, when should we use private instance methods in interfaces?\n\n> \n> As of Java 9, methods in an interface can be private. A private method\n> can be static or an instance method. Since private methods can only be\n> used in the methods of the interface itself, their use is limited to\n> being helper methods for the other methods of the interface.\n> \n> \n> **Cay S. Horstmann, Core Java Volume I - Fundamentals**\n> \n> \n> \n\n\nI get that we can put the common functionality in the private methods and not make it accessible to public. But we can have two kind of private methods here:\n\n\n1. `private`\n2. `private static`\n\n\nUsing `private static` methods is understandable, but when should we use `private` methods? We are not dealing with instances here as this is an interface, so why creating `private` methods is allowed? Don't we need only `private static` methods?\n\n\n","questionMetadata":{"type":"conceptual","level":"advanced","tag":"java"},"answer":"OK, another attempt at actually answering OP's questions. When you need to call another non-static method on the interface from a private method, the private method cannot be static. For example, there would be a compilation error if the private method below was static:\n\n\n\n```\npublic interface InterfaceWithMethods {\n    public default void doSomething() {\n        doSomethingCommon();\n    }\n\n    public default void doSomethingElse() {\n        doSomethingCommon();\n    }\n\n    public void actuallyDoSomething();\n\n    private void doSomethingCommon() {\n        System.out.println(\"Do something first.\");\n        actuallyDoSomething();\n    }\n}\n\n```\n\n"}
{"questionId":"f1166897db13412394c8eae8a93c72e9","question":"VSCode keeps opening powershell on start even though Git Bash is set as default\nI have set my integrated default terminal in VSCode as Git Bash but whenever I launch VSCode, powershell pops up instead of bash. It does not, however, change the default terminal setting but it is irritating.\nI have tried removing the profile of powershell from settings but that seems to do nothing.\nWhy is this happening?\n\n\n","questionMetadata":{"type":"debugging","level":"intermediate","tag":"bash\/shell"},"answer":"This worked for me:\n\n\n\n```\n{\n    \"terminal.integrated.defaultProfile.windows\": \"Git Bash\",\n    \"terminal.integrated.profiles.windows\": {\n        \"PowerShell\": null,\n        \"Git Bash\": {\n            \"source\": \"Git Bash\"\n        },\n        \"Windows PowerShell\": null\n    },\n    \"terminal.integrated.automationShell.windows\": \"Git Bash\",\n    \"powershell.enableProfileLoading\": false,\n    \"powershell.integratedConsole.showOnStartup\": false\n}\n\n```\n\n"}
{"questionId":"bf00e03c52854e5dade37b2292ade5d9","question":"Switching to the system Perl using perlbrew\nFirst, some background.\n\n\n`perlbrew` is a tool to assist with the installation of Perl into a non-standard directory (usually under your home directory).\n\n\nIt also helps you control which Perl installation is used when executing `perl` in an interactive shell. Switching between installations is done using `perlbrew use` and `perlbrew switch`. `perlbrew use` only affects the current shell, while `perlbrew switch` is more permanent.\n\n\n\n```\n$ perl -V:version             |  $ perl -V:version\nversion='5.20.0';             |  version='5.20.0';\n                              |\n$ perlbrew use 5.18.2t        |  $ perlbrew switch 5.18.2t\n                              |\n$ perl -V:version             |  $ perl -V:version\nversion='5.18.2';             |  version='5.18.2';\n                              |\n$ bash -ic 'perl -V:version'  |  $ bash -ic 'perl -V:version'\nversion='5.20.0';             |  version='5.18.2';\n\n```\n\n`perlbrew off` is used to revert to using the system Perl, but it's temporary like `perlbrew use`. Is there a way to revert to the system Perl with the permanency of `perlbrew switch`?\n\n\n","questionMetadata":{"type":"implementation","level":"intermediate","tag":"perl"},"answer":"You can use the following command\n\n\n\n```\nperlbrew switch-off\n\n```\n\n"}
{"questionId":"35491d3d9c7c4c739835580ef546d247","question":"Idea behind \"[...] makes pointer from integer without a cast\"\nI always wondered why warnings `passing argument 1 from of 'foo' makes pointer from integer without a cast` and alike are only warnings and not errors.\n\n\nActually these warnings are almost always errors.\n\n\nDoes somebody know what's the idea behind this? \n\n\n- Is it mostly to allow prehistoric code to be compiled without errors?\n- Or just to comply to the standard? Then latter maybe needs some fixing.\n\n\nExample:\n\n\n\n```\nint foo(int *bar)\n{\n  *bar = 42;\n}\n\nvoid bar()\n{\n  int n = 0;\n  foo(n);      \/\/ this is obviously an error\n  ...\n}\n\n```\n\n","questionMetadata":{"type":"conceptual","level":"advanced","tag":"c"},"answer":"\n> \n> Does somebody know what's the idea behind this?\n> \n> \n> - Is it mostly to allow prehistoric code to be compiled without errors?\n> - Or just to comply to the standard? Then latter maybe needs some fixing.\n> \n> \n> \n\n\nIt is to comply with the standard in the sense that the standard requires conforming implementations to diagnose such issues, as @R.. describes in his answer. Implementations are *not* required to reject programs on account of such issues, however. As for why some compilers instead accept such programs, that would need to be evaluated on a per-implementation basis, but this quotation from the first edition of K&R may shed a bit of light:\n\n\n\n> \n> **5.6 Pointers are not Integers**\n> \n> \n> You may notice in older C programs a rather cavalier attitude toward\n>  copying pointers. It has generally been true that on most machines a\n>  pointer may be assigned to an integer and back again; no scaling or\n>  conversion takes place, and no bits are lost. Regrettably, this has\n>  led to the taking of liberties with routines that return pointers\n>  which are then merely passed to other routines -- the requisite\n>  pointer declarations are often left out.\n> \n> \n> \n\n\n(Kernighan & Ritchie, *The C Programming Language*, 1st ed., 1978)\n\n\nNotice in the first place that this long predates even C89. I'm a bit amused today that the authors were *then* talking about \"older\" C programs. But note too that even at that time, the C language as defined by K&R did not formally permit implicit conversion between pointers and integers (though it did permit casting between them).\n\n\nNevertheless, there were programs that relied on implicit conversion anyway, apparently because it happened to work on the targeted implementations. It was attractive, by some people's standards at the time, in conjunction with primordial C's implicit typing rules. One could let a variable or function intended to return or store a pointer default to type `int` by omitting its declaration altogether, and as long as it was interpreted as a pointer wherever it ultimately was used, everything usually happened to work as intended.\n\n\nI'm inclined to guess that everything continuing to work as intended, thereby supporting backwards compatibility, was a consideration for compiler developers in continuing to accept implicit conversions, so that's \"allow[ing] prehistoric code to be compiled.\" I note, however, that these days code with implicit conversions of this kind are much less likely to work as intended than they used to be, for many machines these days have 64-bit pointers but only 32-bit `int`s.\n\n\n"}
{"questionId":"526433947a884bf3a37c7868e82eff13","question":"jetpack compose java.lang.IllegalStateException: Start\/end imbalance\nthis piece of code cause this crash:\n\n\nim using compose version 1.0.0-alpha06\n\n\n\n> \n> java.lang.IllegalStateException: Start\/end imbalance \u00a0\u00a0at androidx.compose.runtime.Composer.finalizeCompose(Composer.kt:2369) \u00a0\u00a0at androidx.compose.runtime.Composer.endRoot(Composer.kt:575) \u00a0\u00a0at androidx.compose.runtime.Composer.composeInitial(Composer.kt:2054) \u00a0\u00a0at androidx.compose.runtime.Recomposer.composeInitial$runtime\\_release(Recomposer.kt:276) \u00a0\u00a0at androidx.compose.runtime.CompositionImpl.setContent(Composition.kt:110) \u00a0\u00a0at androidx.compose.ui.platform.WrappedComposition$setContent$1.invoke(Wrapper.kt:234) \u00a0\u00a0at androidx.compose.ui.platform.WrappedComposition$setContent$1.invoke(Wrapper.kt:-1) \u00a0\u00a0at androidx.compose.ui.platform.AndroidComposeView.onAttachedToWindow(AndroidComposeView.kt:627) \u00a0\u00a0at android.view.View.dispatchAttachedToWindow(View.java:20479) \u00a0\u00a0at android.view.ViewGroup.dispatchAttachedToWindow(ViewGroup.java:3489) \u00a0\u00a0at android.view.ViewGroup.dispatchAttachedToWindow(ViewGroup.java:3496) \u00a0\u00a0at android.view.ViewGroup.dispatchAttachedToWindow(ViewGroup.java:3496) \u00a0\u00a0at android.view.ViewGroup.dispatchAttachedToWindow(ViewGroup.java:3496) \u00a0\u00a0at android.view.ViewGroup.dispatchAttachedToWindow(ViewGroup.java:3496) \u00a0\u00a0at android.view.AttachInfo\\_Accessor.setAttachInfo(AttachInfo\\_Accessor.java:44)\n> \n> \n> \n\n\ncan someone help me? thanks\n\n\n\n```\n@Composable\n@Preview\nprivate fun Image1() {\n    Box(modifier = Modifier.fillMaxWidth().wrapContentHeight()) {\n        Image(\n                asset = imageResource(id = R.mipmap.fit_static_image_1),\n                contentScale = ContentScale.FillWidth,\n        )\n        Column(Modifier.padding(start = 16.dp, end = 16.dp).align(Alignment.CenterStart), horizontalAlignment = Alignment.Start) {\n            Text(\n                    color = getColor(id = R.color.white),\n                    fontWeight = FontWeight.Bold,\n                    fontSize = TextUnit.Sp(18),\n                    text = dicString(id = R.string.fit_static_image_1_title),\n                    textAlign = TextAlign.Start\n            )\n            Text(\n                    text = dicString(id = R.string.fit_static_image_1_description),\n                    color = getColor(id = R.color.white),\n                    fontSize = TextUnit.Sp(14),\n                    modifier = Modifier.padding(top = 4.dp),\n                    textAlign = TextAlign.Start\n            )\n        }\n    }\n}\n\n```\n\n","questionMetadata":{"type":"debugging","level":"intermediate","tag":"kotlin"},"answer":"i was using **remember { }** wrong, i was trying to use it in **dicString** function to remember obtained string. That caused the issue. I fixed that by adding the resource id to the remember function as parameter. **remember( id ) { }**\n\n\n"}
{"questionId":"86c595ac1a514e7b9d7bf6a420844d2f","question":"Conda dependencies do not install on local package build\nI am building a Python package using `conda-build`. Right now, my structure looks like this:\n\n\n\n```\n- my_recipe\/\n    - meta.yaml\n    - build.sh\n\n```\n\nAnd my `meta.yaml` reads thusly:\n\n\n\n```\npackage:\n  name: my_pkg\nversion: \"0.2.0\"\n\nsource:\n  path: ..\/my_pkg\n\nrequirements:\n  build:\n    - python\n    - setuptools\n  run:\n    - python\n    - pandas\n    - numpy\n    - plotly\n    - matplotlib\n    - pyqtgraph\n    - pyopengl\n    - gdal\n    - scipy\n    - scikit-image\n\n```\n\nThe package itself builds correctly when I run\n\n\n`conda-build my_recipe\/`\n\n\nand it installs successfully when I run\n\n\n`conda install -n my_env --use-local ~\/miniconda3\/envs\/my_env\/conda-bld\/linux-64\/my_pkg-0.2.0-py36_0.tar.bz2`\n\n\nHowever, none of the dependencies listed under `run` seem to install along with the package. For example, when I import the package in Python it says that `pandas` could not be found.\n\n\nAre my dependencies listed in the correct location? Do I also need to list the dependencies in `setup.py`? The documentation is not very clear on where this information should be.\n\n\n","questionMetadata":{"type":"debugging","level":"intermediate","tag":"python"},"answer":"As commented by @darthbith, using the `--use-local` flag with the package name,\n\n\n\n```\nconda install -n my_env --use-local my_pkg\n\n```\n\nworks as intended. Using a path to a tarball directly triggers Conda to install without dependencies.\n\n\n"}
{"questionId":"5447ef504d5246399a1d298ba868bc48","question":"Add a method to existing C++ class in other file\nIs it possible in C++ to extend a class(add a method) in a different source file without editing the original source file where the class is written?\n\n\nIn obj-c it is possible by writing another `@interface AbcClass (ExtCategory) ... @end`\n\n\nI got compile-time error(s) when I tried something like this:\n\n\n\n```\n\/\/Abc.h\nclass Abc {            \/\/This class is from a 3rd party library....\n                       \/\/  ...I don't want to edit its source file.\n    void methodOne();\n    void methodTwo();\n\n}\n\n\n\/\/Abc+Ext.h\nclass Abc {       \/\/ ERROR: Redefinition of 'Abc'\n    void methodAdded();\n}\n\n```\n\nMy target is to retain the 'Abc' name and add methods to it. A specific class in a 3rd party library that I used lacks some methods and I want to add those methods but I am keeping the source file unedited.\n\n\nIs there a way to do this? I am new in writing C++ codes. I am familiar with some of its syntax but don't know much.\n\n\n","questionMetadata":{"type":"implementation","level":"intermediate","tag":"c++"},"answer":"i found out that `c++` is better at doing this than `obj-c`.\n\n\ni tried the following and it works great!\n\n\nthe key is, enclose all of your classes in a namespace and then extend your target classes there with the same class name.\n\n\n\n```\n\/\/Abc.h\nnamespace LibraryA {\n    class Abc {            \/\/This class is from a 3rd party library....\n                           \/\/  ...I don't want to edit its source file.\n        void methodOne();\n        void methodTwo();\n\n    }\n}\n\n\/\/Abc+Ext.hpp\nnamespace MyProj {\n    class Abc : public LibraryA::Abc {\n        using Base = LibraryA::Abc;   \/\/desc: this is to easily access the original class...\n                                      \/\/   ...by using code: Abc::Base::someOrigMethod();\n        using Base::Base;             \/\/desc: inherit all constructors.\n        \n    protected:\n        \/\/---added members:\n        int memberAdded;\n        \n    public:\n        \/\/---added methods:\n        void methodAdded();\n        \n        \/\/---modified virtual member funcs from original class.\n        void origMethod_A() override;\n        \n    }\n}\n\n\/\/Abc+Ext.cpp\nnamespace MyProj {\n    void Abc::origMethod_A() {\n        \/\/...some code here...\n        Base::origMethod_A();    \/\/desc: you can still call the orignal method\n        \/\/...some code here...\n    }\n}\n\n\/\/SomeSourceFile_ThatUses_Abc.cpp\nnamespace MyProj {      \/\/IMPT NOTE: you really need to enclose your...\n                        \/\/   ...project specific code to a namespace so you can...\n                        \/\/   ...use the version of class Abc you extended.\n                        \n                        \n    void SomeClass::SampleFunc(){\n        Abc objX;                   \/\/create MyProj::Abc object.\n        objX.methodAdded();         \/\/calls MyProj::Abc::methodAdded();\n        objX.origMethod_A();        \/\/calls MyProj::Abc::origMethod_A();\n        \n        Abc::Base objY;             \/\/create Library::Abc object.\n        \/\/objY.methodAdded();       \/\/method not existing.\n        objY.origMethod_A();        \/\/calls Library::Abc::origMethod_A();\n        \n        \/\/...some code here...\n    }\n    \n}\n\n\/\/SomeModule.cpp\nnamespace OtherNamespace {\n    void SomeOtherClass::SampleOtherFunc(){\n        Abc objZ;                   \/\/create Library::Abc object.\n        \/\/objZ.methodAdded();       \/\/method not existing.\n        objZ.origMethod_A();        \/\/calls LibraryA::Abc::origMethod_A();\n    }\n    \n}\n\n```\n\nyou can even extend `class Abc` differently within other module namespaces.  \n\n\n\n\n```\n\/\/MyLib_ModuleA_Classes.hpp\nnamespace MyLib_ModuleA {\n    class Abc : public LibraryA::Abc {\n        \/\/...add extensions here...\n        void addedMethod_X();\n        void origMethod_A() override;    \/\/own overriden behavior specific to this ModuleA only.\n    }\n    \n}\n\n\/\/MyLib_ModuleB_Classes.hpp\nnamespace MyLib_ModuleB {\n    class Abc : public LibraryA::Abc {\n        \/\/...add extensions here...\n        void addedMethod_Y();\n        void origMethod_A() override;    \/\/own overriden behavior specific to this ModuleB only.\n    }\n    \n}\n\n```\n\nif in case `class Abc` is in global namespace, though i haven't tried it yet, i think you can just replace `LibaryA::Abc` to `::Abc`.\n\n\nsorry for the very late answer i've been doing this approach for around 4 years now and it's structure is very well useful.\ni tried this in `c++14` but i think this is still doable in `c++11`. now i used `c++17` and it compiles fine. i'm planning to convert to `c++20`\nwhen the compilers i used already completed `c++20` features.\n\n\n"}
{"questionId":"ad8195b11ab24122837e00c9ed607cd6","question":"How to Ignore Duplicate Key Errors Safely Using insert\\_many\nI need to ignore duplicate inserts when using insert\\_many with pymongo, where the duplicates are based on the index. I've seen this question asked on stackoverflow, but I haven't seen a useful answer.\n\n\nHere's my code snippet:\n\n\n\n```\ntry:\n    results = mongo_connection[db][collection].insert_many(documents, ordered=False, bypass_document_validation=True)\nexcept pymongo.errors.BulkWriteError as e:\n    logger.error(e)\n\n```\n\nI would like the insert\\_many to ignore duplicates and not throw an exception (which fills up my error logs). Alternatively, is there a separate exception handler I could use, so that I can just ignore the errors. I miss \"w=0\"...\n\n\nThanks\n\n\n","questionMetadata":{"type":"implementation","level":"intermediate","tag":"python"},"answer":"The correct solution is to use a WriteConcern with w=0 and ordered=False:\n\n\n\n```\nimport pymongo\nfrom pymongo.write_concern import WriteConcern\n\n\nmongodb_connection[db][collection].with_options(write_concern=WriteConcern(w=0)).insert_many(messages, ordered=False)\n\n```\n\n"}
